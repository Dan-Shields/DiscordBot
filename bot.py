'''
EsportsBot
Christian Moulsdale, 2017
'''

import discord
import asyncio

from captcha.image import ImageCaptcha
from functools import wraps
from os import system
from profanity import profanity
from random import choice

# incorrect usage exception
class UsageException(Exception):
    pass

# the esbot class
class esbot(discord.Client):
    # initialise the bot
    def __init__(self, command_prefix = '!'):
        super().__init__()
        self.command_prefix = command_prefix

    # respond to a message and then delete the message and response after a given lifetime with a default of 30s
    async def temp_respond(self, message, str_response, lifetime=30):
        response = await self.send_message(message.channel, str_response)
        await asyncio.sleep(lifetime)
        await self.delete_messages([message, response])

    # respond to a message and then delete the response after a given lifetime with a default of 30s
    async def temp_say(self, channel, str_response, lifetime=30):
        response = await self.send_message(channel, str_response)
        await asyncio.sleep(lifetime)
        await self.delete_message(response)
        
    # output to terminal if the bot successfully logs in
    async def on_ready(self):
        # output information about the bot's login
        print('Logged in as')
        print(self.user.name)
        print(self.user.id)
        print('------')

        # get the list of commands
        self.commands = []
        for att in dir(self):
            if att.startswith('cmd_'):
                self.commands.append(att.replace('cmd_', ''))
        
        # initialise the server variables as global variables
        self.server = discord.utils.get(self.servers, id = '230727209202089984')
        self.member_role = discord.utils.get(self.server.roles, id = '233644097007517697')
        self.committee_role = discord.utils.get(self.server.roles, id = '233643432843804674')
        self.no_merci_emoji = discord.utils.get(self.server.emojis, name = 'nomerci')
        self.team_scrub_emoji = discord.utils.get(self.server.emojis, name = 'teamscrub')
        
        # game roles
        self.games = dict()
        with open('games.txt', 'r') as f:
            for line in f:
                game = line.strip()
                self.games[game.lower()] = discord.utils.get(self.server.roles, name=game)
        
        # set the current game to 'Orisa because she's the best hero'
        await self.change_presence(game = discord.Game(name = 'Orisa because she\'s the best hero'))

        # send prompts to all members who don't currently have the member role
        for member in self.server.members:
            if self.member_role not in member.roles and member != self.user:
                await self.send_terms(member)

    # esborts command wrapper
    def command(usage, committee_only=False):
        def wrapper(func):
            @wraps(func)
            async def sub_wrapper(self, *args, details=False, **kwargs):
                message = kwargs.get('message')
                # if ran as part of help command, return the usage
                if details:
                    response = ''
                    if committee_only:
                        response += 'This command is committee only. '
                    response += 'Correct usage is `{}{}`'.format(self.command_prefix, usage)
                    return await self.temp_respond(message, response)
                # if committe only, check if the user has the committee role
                if committee_only:
                    member = kwargs.get('member')
                    if self.committee_role in member.roles:
                        try:
                            return await func(self, *args, **kwargs)
                        except UsageException:
                            return await self.temp_respond(message, 'Correct usage is `{}{}`'.format(self.command_prefix, usage))
                    else:
                        return await self.temp_respond(message, 'You need to be a committee member to use this command.')
                try:
                    return await func(self, *args, **kwargs)
                except UsageException:
                    return await self.temp_respond(message, 'Correct usage is `{}{}`'.format(self.command_prefix, usage))
            return sub_wrapper
        return wrapper

    # generate a captcha
    async def captcha(self, member):
        while True:
            image = ImageCaptcha(fonts = ['comic_sans.ttf'])
            text = ''.join(choice('0123456789ABCDEF') for i in range(8))
            data = image.generate(text)
            response = await self.send_file(destination = member, fp = data, filename = 'captcha.png', content = 'Please respond to the following captcha. If the captcha is too difficult, a new one can be generated by responding with `New captcha`. Exit by responding with `exit`.')
            data.close()

            # check if the response is a private message from the user
            def check(msg):
                return msg.channel == response.channel

            while True:
                user_response = await self.wait_for_message(author = member, check = check)
                if user_response.content == text:
                    await self.send_message(response.channel, 'Success')
                    return True
                elif user_response.content.lower() == 'exit':
                    await self.send_message(response.channel, 'Ok, exiting the captcha.')
                    return False
                elif user_response.content.lower() == 'new captcha':
                    await self.send_message(response.channel, 'Ok, generating a new captcha.')
                    break
                else:
                    await self.send_message(response.channel, 'Try again. If the captcha is too difficult, a new one can be generated by responding with `New captcha`. Exit by responding with `exit`.')

    #check the contents of the message
    async def on_message(self, message):
        # wait until the bot is ready to process messages
        await self.wait_until_ready()
        
        # get the message content in a managable format
        message_content = message.content.strip()
        message_content_lower = message_content.lower()

        # process the various responses as tasks to avoid async blocking
        task_process = asyncio.ensure_future(self.process_commands(message, message_content, message_content_lower))
        task_accept = asyncio.ensure_future(self.accept_terms(message, message_content_lower))
        task_meme = asyncio.ensure_future(self.meme_response(message, message_content_lower))
        task_christian = asyncio.ensure_future(self.christian_server(message, message_content))

        # finish the tasks
        await task_process
        await task_accept
        await task_meme
        await task_christian

    # check for a command
    async def process_commands(self, message, message_content, message_content_lower):
        if message_content_lower.startswith(self.command_prefix) and message.author != self.user and not message.channel.is_private:
            command, *args = message_content.split()
            command = command.replace(self.command_prefix, '', 1).lower()
            if command in self.commands:
                kwargs = dict()
                kwargs['message'] = message
                kwargs['author'] = message.author
                kwargs['member'] = self.server.get_member(message.author.id)
                
                cmd = getattr(self, 'cmd_{}'.format(command), None)
                await cmd(*args, **kwargs)
            else:
                await self.temp_respond(message, 'Command `{0}{1}` not found. Use `{0}help` to get the list of commands.'.format(self.command_prefix, command))
        
    # check if message is a PM - terms and conditions
    async def accept_terms(self, message, message_content_lower):
        if message.channel.is_private and message.author != self.user:
            yes = False
            no = False
            if message_content_lower.startswith('yes'):
                yes = True
            elif message_content_lower.startswith('no'):
                no = True
            # check if they have the member role
            if self.member_role not in self.server.get_member(message.author.id).roles:
                # check their response if they don't have the member role
                if yes:
                    # user has accepted the terms and conditions
                    # do a captcha
                    if await self.captcha(message.author):
                        await self.send_message(message.author, 'Welcome to the University of Manchester Esports Society discord server!')
                        await self.add_roles(self.server.get_member(message.author.id), self.member_role)
                elif no:
                    # user has rejected the terms and conditions
                    yn = True
                    await self.send_message(message.author, 'Bye!')
                    await self.kick(self.server.get_member(message.author.id))
            elif yes or no:
                await self.send_message(message.author, 'You\'re already a member, dummy!')

    # process the meme responses
    async def meme_response(self, message, message_content_lower):
        if not message.channel.is_private and message.author != self.user:
            if 'behave' in message_content_lower:
                await self.temp_say(message.channel, 'No, you.')
            if 'merci' in message_content_lower:
                await self.add_reaction(message, self.no_merci_emoji)
            if 'scrub' in message_content_lower:
                await self.add_reaction(message, self.team_scrub_emoji)

    # this is a christian server
    async def christian_server(self, message, message_content):
        if profanity.contains_profanity(message_content) and message.author != self.user:
            response = await self.send_file(message.channel, fp = 'christianserverorisa.png', content = profanity.censor(message.content))
            await asyncio.sleep(30)
            await self.delete_message(response)

    # send the terms and conditions prompts to a member
    async def send_terms(self, member):
        await self.send_message(member, content = 'Are you a member of the University of Manchester Esports Society? (`yes` or `no`)')

    # when a member joins, send them a PM asking if they accept the terms and conditions
    async def on_member_join(self, member):
        await self.send_terms(member)
        
    # list the bot commands
    @command(usage='help [command]')
    async def cmd_help(self, *args, **kwargs):
        # check if a command has been given to list the usage
        if len(args) == 1:
            if args[0] in self.commands:
                cmd = getattr(self, 'cmd_{}'.format(args[0]))
                await cmd(*args, **kwargs, details=True)
        else:
            message = kwargs.get('message')
            response = '**EsportsBot commands**\n```!'
            response += ', !'.join(self.commands)
            response += '```'
            await self.temp_respond(message, response)

    # restart the bot
    @command(usage='restart', committee_only=True)
    async def cmd_restart(self, *args, **kwargs):
        message = kwargs.get('message')
        author = kwargs.get('author')
        await self.send_message(author, 'Restarting.')
        await self.delete_message(message)
        print('Restarting the bot.')
        print('------')
        system('python3 bot.py')
        exit()

    # add game role
    @command(usage='addrole [games]')
    async def cmd_addrole(self, *args, **kwargs):
        member = kwargs.get('member')
        message = kwargs.get('message')
        if len(args) != 0:
            response = ''
            roles = []
            for arg in args:
                if arg.lower() in self.games:
                    role = self.games[arg.lower()]
                    roles.append(role)
                    response += 'Added `{}` role\n'.format(role.name)
                else:
                    response += 'Didn\'t recognise `{}` role \n'.format(arg)
            await self.add_roles(member, *roles)
            await self.temp_respond(message, response)
        else:
            raise UsageException

    # remove game role
    @command(usage='removerole [games]')
    async def cmd_removerole(self, *args, **kwargs):
        member = kwargs.get('member')
        message = kwargs.get('message')
        if len(args) != 0:
            response = ''
            roles = []
            for arg in args:
                if arg.lower() in self.games:
                    role = self.games[arg.lower()]
                    if role in member.roles:
                        roles.append(role)
                        response += 'Removed `{}` role\n'.format(role.name)
                    else:
                        response += 'You don\'t have `{}` role\n'.format(role.name)
                else:
                    response += 'Didn\'t recognise `{}` role \n'.format(arg)
            await self.remove_roles(member, *roles)
            await self.temp_respond(message, response)
        else:
            raise UsageException
            
# start the bot
bot = esbot()
bot.run('token')
